//พารามิเตอร์ในส่วนของหุ่นยนต์หลบหลีกสิ่งกีดขวาง ***
#include <Servo.h> //เรียกไลบารี่ที่ใช้งานเซอร์โวมอเตอร์ ***
Servo Myservo; //ประกาศออปเจ็กต์ในการใช้งานเซอร์โวมอเตอร์ ***
float duration; //ประกาศตัวแปรเพื่อเก็บระยะเวลาที่อัลตราโซนิกสะท้อนของเซ็นเซอร์ ****
volatile float distance; //ประกาศตัวแปรเพื่อเก็บระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์ของหุ่นยนต์ ****

#define TrigPin 13  // ขา Trig Pin ของ HC-SR04 ***
#define EchoPin 12  // ขา Echo Pin ของ HC-SR04 ***

#define ServoPin 11 // ขา Signal ขับ PWM ของ Servo Motor ออกที่ขา 11 ***

#define Int_IRDetect_L 0 // ขา 0 ต่อเข้า IR Detect Sensor ที่ด้านซ้าย ****
#define Int_IRDetect_R 1 // ขา 1 ต่อเข้า IR Detect Sensor ที่ด้านขวา ****

#define Int_wheel_R 2 //กำหนดขาอินพุตที่ต่อจากเซ็นเซอร์ Opto ที่ล้อขวา (ที่ขา INT 0)
#define Int_wheel_L 3 //กำหนดขาอินพุตที่ต่อจากเซ็นเซอร์ Opto ที่ล้อซ้าย (ที่ขา INT 1)
#define PI 3.1415926535897932384626433832795 //กำหนดค่าของ Pi
#define Wheel_Radiant 3.4925 // รัศมีของล้อ
//ล้อขวา
int ENA=10; //กำหนดให้ขาที่ 10 เชื่อมต่อกับขา ENA ของ L298N
int IN1=9; //กำหนดให้ขาที่ 9 เชื่อมต่อกับขา IN1 ของ L298N
int IN2=8; //กำหนดให้ขาที่ 8 เชื่อมต่อกับขา IN2 ของ L298N
//ล้อซ้าย
int ENB=5; //กำหนดให้ขาที่ 5 เชื่อมต่อกับขา ENB ของ L298N
int IN3=7; //กำหนดให้ขาที่ 7 เชื่อมต่อกับขา IN3 ของ L298N
int IN4=6; //กำหนดให้ขาที่ 6 เชื่อมต่อกับขา IN4 ของ L298N

volatile unsigned int noClk_R = 0; //กำหนดตัวแปรที่ใช้นับจำนวน 1 พัลส์จาก Encoder Disk ที่ล้อขวา
volatile unsigned int noClk_L = 0; //กำหนดตัวแปรที่ใช้นับจำนวน 1 พัลส์จาก Encoder Disk ที่ล้อซ้าย

float noSlots = 20.00; //จำนวนช่องว่างของ Encoder Disk บนจานล้อหมุน
float round_distance = 2*PI*Wheel_Radiant; //ระยะทางของล้อหุ่นยนต์ต่อการหมุน 1 รอบ (เส้นรอบวง) หน่วยเป็น ซม. ใช้สูตร 2xPixรัศมีของล้อ
float one_tick = round_distance/noSlots; //ค่าระยะทางการเดินทางของล้อจำนวน 1 พัลส์ที่นับได้จากขา IRQ
float length_wheelbase = 13.5; //ค่าความยาวของฐานล้อ หน่วยเป็นเซ็นติเมตร
float circumference = 2*PI*length_wheelbase; //ระยะทางการเคลื่อนที่ของหุ่นยนต์ในล้อซ้ายหรือล้อขวาในกรณีหมุนครบ 360 องศา Question 1
float TT_noPulse_IRQ = circumference/one_tick; //จำนวนพัลส์ที่นับได้ใน ISR ที่ล้อซ้ายหรือล้อขวาในกรณีที่หุ่นยนต์เลี้ยวครบ 360 องศา Question 2
float anglePerIRQ = 360/TT_noPulse_IRQ; //ค่าองศาที่เกิดขึ้นของการเลี้ยวต่อการนับจำนวนพัลส์ 1 พัลส์ใน ISR Question 3

float distance_R = 0; //ตัวแปรที่ใช้เก็บระยะทางการเดินทางของล้อขวาหน่วยเป็นเซ็นติเมตร
float distance_L = 0; //ตัวแปรที่ใช้เก็บระยะทางการเดินทางของล้อซ้ายหน่วยเป็นเซ็นติเมตร

void ISR_detect_R(){ // เซ็นเซอร์ IR Detect ตรวจจับได้ว่ามีวัตถุอยู่ในระยะ 20 - 24 ซม. ที่ล้อขวา ****
  distance = 23;
}

void ISR_detect_L(){ // เซ็นเซอร์ IR Detect ตรวจจับได้ว่ามีวัตถุอยู่ในระยะ 20 - 24 ซม. ที่ล้อซ้าย ****
  distance = 23;
}

void ISR_count_R(){ // นับจำนวนพัลส์ที่ผ่านช่องว่างของ Encoder Disk บนจานล้อหมุนที่ล้อขวา
  noClk_R = noClk_R + 1; //เพิ่มค่าจำนวนของตัวแปรที่ใช้นับ IRQ ที่ล้อขวาไป 1
}

void ISR_count_L(){ // นับจำนวนพัลส์ที่ผ่านช่องว่างของ Encoder Disk บนจานล้อหมุนที่ล้อซ้าย
  noClk_L = noClk_L + 1; //เพิ่มค่าจำนวนของตัวแปรที่ใช้นับ IRQ ที่ล้อซ้ายไป 1
}
// ฟังก์ชั่นนี้จะทำหน้าที่สั่งให้หุ่นยนต์ทำการวัดระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์อัลตราโซนิก HC-SR04 ออกมาเป็นเซ็นติเมตร มาเก็บไว้ในตัวแปร distance ***
void Get_Distance(){ // ***
  digitalWrite(TrigPin, LOW);   // เคลียร์ค่าที่ขา Trig ของ HC-SR04 ***
  delayMicroseconds(2);   // ดีเลย์ไป 2 ไมโครวินาที ***
  digitalWrite(TrigPin, HIGH);  // สั่งให้ขา Trig ทำการส่งคลื่นอัลตราโซนิก ความถี่ 40 KHz จำนวน 8 ลูก ออกไปที่ปล้องของ Transmit ***
  delayMicroseconds(10); // ดีเลย์ไป 10 ไมโครวินาที ***
  duration = pulseIn(EchoPin, HIGH);        // รับคลื่นสะท้อนที่รับกลับมาที่ขา Echo ***
  distance = (duration*.0343)/2;            // คำนวณหาระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์หรือสิ่งกีดขวางที่อยู่ด้านหน้าหน่วยเป็น เซ็นติเมตร ***
  delay(10); //ดีเลย์ไป 10 มิลลิวินาที ***
}
//ฟังก์ชั่นนี้จะทำการแปลงระยะทางการเดินของหุ่นยนต์จากหน่วยเซ็นติเมตรเป็นจำนวนพัลส์ที่ต้องนับใน ISR สำหรับดักค่า IRQ ในล้อซ้ายและล้อขวา ใช้ในกรณีเดินหน้าและถอยหลัง
int CM_To_noClk(float IP_cm){
  float TT_noClk_B = IP_cm/one_tick;
  int TT_noClk = (int) TT_noClk_B;
  return TT_noClk;
}
//ฟังก์ชั่นนี้จะทำการแปลงความเร็วของหุ่นยนต์จากหน่วยเซ็นติเมตร/วินาทีเป็นค่า Duty Cycle ของ PWM เพื่อใช้ป้อนให้กับขา ENA และ ENB ของ L298N
int SP_To_PWM(float IP_sp){
  int TT_PWM = map(IP_sp,0,70,0,4095); //แม็พค่าความเร็วสูงสุดของหุ่นยนต์ ในที่นี้คือ 70 เซ็นติเมตรต่อวินาทีให้มีค่าระหว่าง 0-4095
  return TT_PWM;
}
//ฟังก์ชั่นนี้จะทำการแปลงค่าองศาการเลี้ยวของหุ่นยนต์ไปเป็นจำนวนพัลส์ที่ต้องนับใน ISR สำหรับดักค่า IRQ ในล้อซ้ายหรือล้อขวา ใช้ในกรณีเลี้ยวซ้ายและเลี้ยวขวา
int DGT_To_noClk(float IP_dg){
  float TT_noClk_D = IP_dg*(1/anglePerIRQ);
  int TT_noClk = (int) TT_noClk_D;
  return TT_noClk;
}
//ฟังก์ชั่นนี้จะทำการแปลงค่าองศาการหมุนของหุ่นยนต์ไปเป็นจำนวนพัลส์ที่ต้องนับใน ISR สำหรับดักค่า IRQ ในล้อซ้ายและล้อขวา ใช้ในกรณีหมุนซ้ายและหมุนขวา
int DGR_To_noClk(float IP_dgr){
  float TT_noClk_DR = IP_dgr*(1/(2*anglePerIRQ));
  int TT_noClk = (int) TT_noClk_DR;
  return TT_noClk;
}
//ฟังก์ชั่นนี้จะทำให้หุ่นยนต์เคลื่อนที่ไปด้านหน้าด้วยความเร็วคงที่ อินพุตจะมี 2 ค่าคือ ความเร็วของหุ่นยนต์มีหน่วยเป็นเซ็นติเมตรต่อวินาที และ ระยะทางที่ต้องการให้หุ่นยนต์เคลื่อนที่มีหน่วยเป็นเซ็นติเมตร
void forward(float CMpS_speed, float CM_distance){
  //กำหนดพารามิเตอร์ที่ L298N เพื่อให้หุ่นยนต์เดินไปด้านหน้า
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
  //ทำการแปลงค่าความเร็วของหุ่นยนต์เป็น PWM
  int PWM_speed = SP_To_PWM(CMpS_speed);
  //ทำการแปลงค่าระยะทางที่ต้องการให้หุ่นยนต์เคลื่อนที่เป็นจำนวนพัลส์ที่ต้องใช้นับใน ISR
  int Pulse_distance = CM_To_noClk(CM_distance);
  //ทำการดักค่าจำนวนพัลส์ใน IRQ ว่าครบตามกำหนดระยะทางแล้วหรือยังถ้าครบตามจำนวนที่กำหนดแล้วให้หุ่นยนต์หยุดการเคลื่อนที่
  while (Pulse_distance > noClk_R && Pulse_distance > noClk_L){
    //ในกรณีล้อขวา
    if(Pulse_distance > noClk_R){ 
      analogWrite(ENA, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อขวา
    }
    else{
      analogWrite(ENA, 0); //ถ้าถึงระยะทางที่กำหนดให้ล้อขวาหยุด
    }
    //ในกรณีล้อซ้าย
    if(Pulse_distance > noClk_L){
      analogWrite(ENB, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อซ้าย
    }
    else{
      analogWrite(ENB, 0); //ถ้าถึงระยะทางที่กำหนดให้ล้อซ้ายหยุด
    }
  }
  //ใช้สำหรับดักค่า PWM ในกรณีที่ Duty Cycle ต่ำกว่าที่ L298N จะสามารถเอาไปขับมอเตอร์ให้หมุนได้ ป้องกันความเสียหายของมอเตอร์ในช่วง 0-2050 (ในที่นี้ความเร็วในการสั่งงานของมอเตอร์อยู่ที่ 0 - 4095)
  if (PWM_speed < 2050){
    PWM_speed = 0;
  }
  //ทำการหยุดการเคลื่อนที่ของหุ่นยนต์เมื่อทำภารกิจเดินหน้าสำเร็จตามระยะทางที่กำหนด
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
}

//ฟังก์ชั่นนี้จะทำให้หุ่นยนต์เคลื่อนที่ไปด้านหลังด้วยความเร็วคงที่ อินพุตจะมี 2 ค่าคือ ความเร็วของหุ่นยนต์มีหน่วยเป็นเซ็นติเมตรต่อวินาที และ ระยะทางที่ต้องการให้หุ่นยนต์เคลื่อนที่มีหน่วยเป็นเซ็นติเมตร
void backward(float CMpS_speed, float CM_distance){
  //กำหนดพารามิเตอร์ที่ L298N เพื่อให้หุ่นยนต์เดินถอยหลัง
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
  //ทำการแปลงค่าความเร็วของหุ่นยนต์เป็น PWM
  int PWM_speed = SP_To_PWM(CMpS_speed);
  //ทำการแปลงค่าระยะทางที่ต้องการให้หุ่นยนต์เคลื่อนที่เป็นจำนวนพัลส์ที่ต้องใช้นับใน ISR
  int Pulse_distance = CM_To_noClk(CM_distance);
  //ทำการดักค่าจำนวนพัลส์ใน IRQ ว่าครบตามกำหนดระยะทางแล้วหรือยังถ้าครบตามจำนวนที่กำหนดแล้วให้หุ่นยนต์หยุดการเคลื่อนที่
  while (Pulse_distance > noClk_R && Pulse_distance > noClk_L){
    //ในกรณีล้อขวา
    if(Pulse_distance > noClk_R){ 
      analogWrite(ENA, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อขวา
    }
    else{
      analogWrite(ENA, 0); //ถ้าถึงระยะทางที่กำหนดให้ล้อขวาหยุด
    }
    //ในกรณีล้อซ้าย
    if(Pulse_distance > noClk_L){
      analogWrite(ENB, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อซ้าย
    }
    else{
      analogWrite(ENB, 0); //ถ้าถึงระยะทางที่กำหนดให้ล้อซ้ายหยุด
    }
  }
  //ใช้สำหรับดักค่า PWM ในกรณีที่ Duty Cycle ต่ำกว่าที่ L298N จะสามารถเอาไปขับมอเตอร์ให้หมุนได้ ป้องกันความเสียหายของมอเตอร์ในช่วง 0-2050 (ในที่นี้ความเร็วในการสั่งงานของมอเตอร์อยู่ที่ 0 - 4095)
  if (PWM_speed < 2050){
    PWM_speed = 0;
  }
  //ทำการหยุดการเคลื่อนที่ของหุ่นยนต์เมื่อทำภารกิจเดินหน้าสำเร็จตามระยะทางที่กำหนด
  analogWrite(ENA, 0);
  analogWrite(ENB, 0); 
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
}

//ฟังก์ชั่นนี้จะทำให้หุ่นยนต์ทำการเลี้ยวขวาแบบเดินหน้า อินพุตมีอยู่ 2 ค่าคือ ค่าความเร็วของการเลี้ยวมีหน่วยเป็นเซ็นติเมตรต่อวินาทีและองศาการเลี้ยวมีหน่วยเป็นองศา
void turn_right_forward(float CMpS_speed, float DG_turn){
  //กำหนดพารามิเตอร์ที่ L298N เพื่อให้หุ่นยนต์ทำการเลี้ยวขวา (ใช้เหมือนกับกรณีเดินหน้าเพียงแต่ว่ากำหนดความเร็วให้เพียงล้อซ้ายและหยุดล้อขวา)
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
  //ทำการแปลงค่าความเร็วของหุ่นยนต์เป็น PWM
  int PWM_speed = SP_To_PWM(CMpS_speed);
  //ทำการแปลงค่าองศาการเลี้ยวให้เป็นค่าจำนวนพัลส์ที่จะต้องใช้นับในล้อซ้าย
  int Pulse_angle = DGT_To_noClk(DG_turn);
  //ทำการดักค่าจำนวนพัลส์ใน IRQ ที่ล้อซ้ายว่าครบตามกำหนดระยะทางแล้วหรือยังถ้าครบตามจำนวนที่กำหนดแล้วให้หุ่นยนต์หยุดการเคลื่อนที่
  while (Pulse_angle > noClk_L){
    //ในกรณีล้อซ้าย
    if(Pulse_angle > noClk_L){
      analogWrite(ENA, 0); //ล้อขวาหยุดหมุน
      analogWrite(ENB, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อซ้าย
    }
    else{ //ถ้าถึงระยะทางที่กำหนดให้ล้อซ้ายและขวาหยุด
      analogWrite(ENA, 0);
      analogWrite(ENB, 0); 
    }
  }
  //ใช้สำหรับดักค่า PWM ในกรณีที่ Duty Cycle ต่ำกว่าที่ L298N จะสามารถเอาไปขับมอเตอร์ให้หมุนได้ ป้องกันความเสียหายของมอเตอร์ในช่วง 0-2050 (ในที่นี้ความเร็วในการสั่งงานของมอเตอร์อยู่ที่ 0 - 4095)
  if (PWM_speed < 2050){
    PWM_speed = 0;
  }
  //ทำการหยุดการเคลื่อนที่ของหุ่นยนต์เมื่อทำภารกิจเดินหน้าสำเร็จตามระยะทางที่กำหนด
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
}

//ฟังก์ชั่นนี้จะทำให้หุ่นยนต์ทำการเลี้ยวขวาแบบถอยหลัง อินพุตมีอยู่ 2 ค่าคือ ค่าความเร็วของการเลี้ยวมีหน่วยเป็นเซ็นติเมตรต่อวินาทีและองศาการเลี้ยวมีหน่วยเป็นองศา
void turn_right_backward(float CMpS_speed, float DG_turn){
  //กำหนดพารามิเตอร์ที่ L298N เพื่อให้หุ่นยนต์ทำการเลี้ยวขวา (ใช้เหมือนกับกรณีเดินหน้าเพียงแต่ว่ากำหนดความเร็วให้เพียงล้อซ้ายและหยุดล้อขวา)
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
  //ทำการแปลงค่าความเร็วของหุ่นยนต์เป็น PWM
  int PWM_speed = SP_To_PWM(CMpS_speed);
  //ทำการแปลงค่าองศาการเลี้ยวให้เป็นค่าจำนวนพัลส์ที่จะต้องใช้นับในล้อซ้าย
  int Pulse_angle = DGT_To_noClk(DG_turn);
  //ทำการดักค่าจำนวนพัลส์ใน IRQ ที่ล้อซ้ายว่าครบตามกำหนดระยะทางแล้วหรือยังถ้าครบตามจำนวนที่กำหนดแล้วให้หุ่นยนต์หยุดการเคลื่อนที่
  while (Pulse_angle > noClk_L){
    //ในกรณีล้อซ้าย
    if(Pulse_angle > noClk_L){
      analogWrite(ENA, 0); //ล้อขวาหยุดหมุน
      analogWrite(ENB, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อซ้าย
    }
    else{ //ถ้าถึงระยะทางที่กำหนดให้ล้อซ้ายและขวาหยุด
      analogWrite(ENA, 0);
      analogWrite(ENB, 0); 
    }
  }
  //ใช้สำหรับดักค่า PWM ในกรณีที่ Duty Cycle ต่ำกว่าที่ L298N จะสามารถเอาไปขับมอเตอร์ให้หมุนได้ ป้องกันความเสียหายของมอเตอร์ในช่วง 0-2050 (ในที่นี้ความเร็วในการสั่งงานของมอเตอร์อยู่ที่ 0 - 4095)
  if (PWM_speed < 2050){
    PWM_speed = 0;
  }
  //ทำการหยุดการเคลื่อนที่ของหุ่นยนต์เมื่อทำภารกิจเดินหน้าสำเร็จตามระยะทางที่กำหนด
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
}

//ฟังก์ชั่นนี้จะทำให้หุ่นยนต์ทำการเลี้ยวซ้ายแบบเดินหน้า อินพุตมีอยู่ 2 ค่าคือ ค่าความเร็วของการเลี้ยวมีหน่วยเป็นเซ็นติเมตรต่อวินาทีและองศาการเลี้ยวมีหน่วยเป็นองศา
void turn_left_forward(float CMpS_speed, float DG_turn){
  //กำหนดพารามิเตอร์ที่ L298N เพื่อให้หุ่นยนต์ทำการเลี้ยวซ้าย (ใช้เหมือนกับกรณีเดินหน้าเพียงแต่ว่ากำหนดความเร็วให้เพียงล้อขวาและหยุดล้อซ้าย)
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
  //ทำการแปลงค่าความเร็วของหุ่นยนต์เป็น PWM
  int PWM_speed = SP_To_PWM(CMpS_speed);
  //ทำการแปลงค่าองศาการเลี้ยวให้เป็นค่าจำนวนพัลส์ที่จะต้องใช้นับในล้อขวา
  int Pulse_angle = DGT_To_noClk(DG_turn);
  //ทำการดักค่าจำนวนพัลส์ใน IRQ ที่ล้อขวาว่าครบตามกำหนดระยะทางแล้วหรือยังถ้าครบตามจำนวนที่กำหนดแล้วให้หุ่นยนต์หยุดการเคลื่อนที่
  while (Pulse_angle > noClk_R){
    //ในกรณีล้อขวา
    if(Pulse_angle > noClk_R){
      analogWrite(ENA, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อขวา
      analogWrite(ENB, 0); //ล้อซ้ายหยุดหมุน
    }
    else{ //ถ้าถึงระยะทางที่กำหนดให้ล้อซ้ายและขวาหยุด
      analogWrite(ENA, 0);
      analogWrite(ENB, 0); 
    }
  }
  //ใช้สำหรับดักค่า PWM ในกรณีที่ Duty Cycle ต่ำกว่าที่ L298N จะสามารถเอาไปขับมอเตอร์ให้หมุนได้ ป้องกันความเสียหายของมอเตอร์ในช่วง 0-2050 (ในที่นี้ความเร็วในการสั่งงานของมอเตอร์อยู่ที่ 0 - 4095)
  if (PWM_speed < 2050){
    PWM_speed = 0;
  }
  //ทำการหยุดการเคลื่อนที่ของหุ่นยนต์เมื่อทำภารกิจเดินหน้าสำเร็จตามระยะทางที่กำหนด
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
}

//ฟังก์ชั่นนี้จะทำให้หุ่นยนต์ทำการเลี้ยวซ้ายแบบถอยหลัง อินพุตมีอยู่ 2 ค่าคือ ค่าความเร็วของการเลี้ยวมีหน่วยเป็นเซ็นติเมตรต่อวินาทีและองศาการเลี้ยวมีหน่วยเป็นองศา
void turn_left_backward(float CMpS_speed, float DG_turn){
  //กำหนดพารามิเตอร์ที่ L298N เพื่อให้หุ่นยนต์ทำการเลี้ยวซ้าย (ใช้เหมือนกับกรณีเดินหน้าเพียงแต่ว่ากำหนดความเร็วให้เพียงล้อขวาและหยุดล้อซ้าย)
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
  //ทำการแปลงค่าความเร็วของหุ่นยนต์เป็น PWM
  int PWM_speed = SP_To_PWM(CMpS_speed);
  //ทำการแปลงค่าองศาการเลี้ยวให้เป็นค่าจำนวนพัลส์ที่จะต้องใช้นับในล้อขวา
  int Pulse_angle = DGT_To_noClk(DG_turn);
  //ทำการดักค่าจำนวนพัลส์ใน IRQ ที่ล้อขวาว่าครบตามกำหนดระยะทางแล้วหรือยังถ้าครบตามจำนวนที่กำหนดแล้วให้หุ่นยนต์หยุดการเคลื่อนที่
  while (Pulse_angle > noClk_R){
    //ในกรณีล้อขวา
    if(Pulse_angle > noClk_R){
      analogWrite(ENA, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อขวา
      analogWrite(ENB, 0); //ล้อซ้าย
    }
    else{ //ถ้าถึงระยะทางที่กำหนดให้ล้อซ้ายและขวาหยุด
      analogWrite(ENA, 0);
      analogWrite(ENB, 0); 
    }
  }
  //ใช้สำหรับดักค่า PWM ในกรณีที่ Duty Cycle ต่ำกว่าที่ L298N จะสามารถเอาไปขับมอเตอร์ให้หมุนได้ ป้องกันความเสียหายของมอเตอร์ในช่วง 0-2050 (ในที่นี้ความเร็วในการสั่งงานของมอเตอร์อยู่ที่ 0 - 4095)
  if (PWM_speed < 2050){
    PWM_speed = 0;
  }
  //ทำการหยุดการเคลื่อนที่ของหุ่นยนต์เมื่อทำภารกิจเดินหน้าสำเร็จตามระยะทางที่กำหนด
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
}

//ฟังก์ชั่นนี้จะทำให้หุ่นยนต์ทำการหมุนขวา อินพุตมีอยู่ 2 ค่าคือ ค่าความเร็วของการหมุนมีหน่วยเป็นเซ็นติเมตรต่อวินาทีและองศาการหมุนมีหน่วยเป็นองศา
void spin_right(float CMpS_speed, float DG_spin){
  //กำหนดพารามิเตอร์ที่ L298N เพื่อให้หุ่นยนต์ทำการหมุนขวา (ล้อซ้ายเดินหน้าล้อขวาถอยหลัง)
  digitalWrite(IN1, HIGH); //ล้อซ้าย
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW); //ล้อขวา
  digitalWrite(IN4, HIGH);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
  //ทำการแปลงค่าความเร็วของหุ่นยนต์เป็น PWM
  int PWM_speed = SP_To_PWM(CMpS_speed);
  //ทำการแปลงค่าองศาการหมุนให้เป็นค่าจำนวนพัลส์ที่จะต้องใช้นับในล้อขวา
  int Pulse_angle = DGR_To_noClk(DG_spin);
  //ทำการดักค่าจำนวนพัลส์ใน IRQ ที่ล้อซ้ายว่าครบตามกำหนดระยะทางแล้วหรือยังถ้าครบตามจำนวนที่กำหนดแล้วให้หุ่นยนต์หยุดการเคลื่อนที่
  while (Pulse_angle > noClk_L){
    //ในกรณีล้อซ้ายและขวา
    if(Pulse_angle > noClk_L){
      analogWrite(ENA, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อขวา
      analogWrite(ENB, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อซ้าย
    }
    else{ //ถ้าถึงระยะทางที่กำหนดให้ล้อซ้ายและขวาหยุด
      analogWrite(ENA, 0);
      analogWrite(ENB, 0); 
    }
  }
  //ใช้สำหรับดักค่า PWM ในกรณีที่ Duty Cycle ต่ำกว่าที่ L298N จะสามารถเอาไปขับมอเตอร์ให้หมุนได้ ป้องกันความเสียหายของมอเตอร์ในช่วง 0-2050 (ในที่นี้ความเร็วในการสั่งงานของมอเตอร์อยู่ที่ 0 - 4095)
  if (PWM_speed < 2050){
    PWM_speed = 0;
  }
  //ทำการหยุดการเคลื่อนที่ของหุ่นยนต์เมื่อทำภารกิจเดินหน้าสำเร็จตามระยะทางที่กำหนด
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
}

//ฟังก์ชั่นนี้จะทำให้หุ่นยนต์ทำการหมุนซ้าย อินพุตมีอยู่ 2 ค่าคือ ค่าความเร็วของการหมุนมีหน่วยเป็นเซ็นติเมตรต่อวินาทีและองศาการหมุนมีหน่วยเป็นองศา
void spin_left(float CMpS_speed, float DG_spin){
  //กำหนดพารามิเตอร์ที่ L298N เพื่อให้หุ่นยนต์ทำการหมุนซ้าย (ล้อซ้ายถอยหลังล้อขวาเดินหน้า)
  digitalWrite(IN1, LOW); //ล้อซ้าย
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, HIGH); //ล้อขวา
  digitalWrite(IN4, LOW);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
  //ทำการแปลงค่าความเร็วของหุ่นยนต์เป็น PWM
  int PWM_speed = SP_To_PWM(CMpS_speed);
  //ทำการแปลงค่าองศาการหมุนให้เป็นค่าจำนวนพัลส์ที่จะต้องใช้นับในล้อขวา
  int Pulse_angle = DGR_To_noClk(DG_spin);
  //ทำการดักค่าจำนวนพัลส์ใน IRQ ที่ล้อขวาว่าครบตามกำหนดระยะทางแล้วหรือยังถ้าครบตามจำนวนที่กำหนดแล้วให้หุ่นยนต์หยุดการเคลื่อนที่
  while (Pulse_angle > noClk_R){
    //ในกรณีล้อซ้ายและขวา
    if(Pulse_angle > noClk_R){
      analogWrite(ENA, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อขวา
      analogWrite(ENB, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อซ้าย
    }
    else{ //ถ้าถึงระยะทางที่กำหนดให้ล้อซ้ายและขวาหยุด
      analogWrite(ENA, 0);
      analogWrite(ENB, 0); 
    }
  }
  //ใช้สำหรับดักค่า PWM ในกรณีที่ Duty Cycle ต่ำกว่าที่ L298N จะสามารถเอาไปขับมอเตอร์ให้หมุนได้ ป้องกันความเสียหายของมอเตอร์ในช่วง 0-2050 (ในที่นี้ความเร็วในการสั่งงานของมอเตอร์อยู่ที่ 0 - 4095)
  if (PWM_speed < 2050){
    PWM_speed = 0;
  }
  //ทำการหยุดการเคลื่อนที่ของหุ่นยนต์เมื่อทำภารกิจเดินหน้าสำเร็จตามระยะทางที่กำหนด
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
}

//ฟังก์ชั่นนี้จะทำให้หุ่นยนต์หยุดเดิน
void stop(){
  //กำหนดพารามิเตอร์ที่ L298N เพื่อให้หุ่นยนต์เพื่อให้หุ่นยนต์หยุดเดิน
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, LOW);
}

void setup() {
  pinMode(ENA, OUTPUT);
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(ENB, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);

  pinMode(TrigPin, OUTPUT); // กำหนดให้ขา TrigPin (ขาที่ 13) เป็นเอาต์พุต***
  pinMode(EchoPin, INPUT); // กำหนดให้ขา EchoPin (ขาที่ 12) เป็นอินพุต ***
  //ประกาศเพื่อเรียกใช้งานพอร์ต UART เพื่อส่งค่ากลับไปยัง Serial Monitor ***
  Serial.begin(9600); // ***
  //กำหนดค่าในการทำ Hardware IRQ
  attachInterrupt(digitalPinToInterrupt(Int_wheel_R), ISR_count_R, RISING); // กำหนดพารามิเตอร์สำหรับ HW IRQ ให้กับล้อขวาเพื่อนับจำนวนพัลส์ที่ขอบขาขึ้น
  attachInterrupt(digitalPinToInterrupt(Int_wheel_L), ISR_count_L, RISING); // กำหนดพารามิเตอร์สำหรับ HW IRQ ให้กับล้อซ้ายเพื่อนับจำนวนพัลส์ที่ขอบขาขึ้น
  
  attachInterrupt(digitalPinToInterrupt(Int_IRDetect_R), ISR_detect_R, FALLING); // กำหนดพารามิเตอร์สำหรับ HW IRQ ให้กับการตรวจจับที่ด้านขวาที่ขอบขาลง ****
  attachInterrupt(digitalPinToInterrupt(Int_IRDetect_L), ISR_detect_L, FALLING); // กำหนดพารามิเตอร์สำหรับ HW IRQ ให้กับการตรวจจับที่ด้านซ้ายที่ขอบขาลง ****

  analogWriteResolution(12); //เปลี่ยนความละเอียดของ PWM จาก 0 - 255 เป็น 0 - 4095
  
  Myservo.attach(ServoPin); //ขาดาต้าของเซอร์โวต่อที่ขา 11 ***
  Myservo.write(100); //กำหนดให้ค่าเริ่มต้นขององศาการขยับของเซอร์โวอยู่ตรงกลาง คือ 90 องศา (ชดเชยการ Jitter ไป 10 องศา) ***
  delay(500); // ทำการดีเลย์รอให้เซอร์โวมอเตอร์ปัดแกนไปที่ 90 องศาไปครึ่งวินาที ***
}

void loop() {
  Get_Distance(); // ทำการวัดค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์จาก HC-SR04 ***
  Serial.print("ค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์ตรวจจับได้ขณะวิ่งตรง: "); // แสดงค่าที่ได้จากการวัดระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์ออก Serial Monitor ***
  Serial.print(distance); // แสดงค่า distance ออกไปยัง Serial Monitor ***
  Serial.println(" เซ็นติเมตร"); // แสดงค่าที่ได้จากการวัดระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์ออก Serial Monitor ***

  if (distance > 25){ // ถ้าวัตถุอยู่ด้านหน้ามีระยะทางมากกว่า 25 ซม. ***
    Myservo.write(100); // ตั้งเซอร์โวให้อยู่ตรงกลางที่ 90 องศา ***
    forward(40, 10); //ให้หุ่นยนต์เคลื่อนที่ด้วยความเร็ว 40 เซ็นติเมตรต่อวินาทีเป็นระยะทาง 10 เซ็นติเมตร ***
    Get_Distance(); // ทำการวัดค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์จาก HC-SR04 ***
  }
  else if ((distance < 25)&&(distance > 5)) { // ถ้าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์อยู่ระหว่าง 25 ถึง 5 ซม. ***
    float d_0 = 0; // ตัวแปรที่ใช้เก็บระยะห่างของวัตถุที่ 0 องศา ***
    float d_30 = 0; // ตัวแปรที่ใช้เก็บระยะห่างของวัตถุที่ 30 องศา ***
    float d_60 = 0; // ตัวแปรที่ใช้เก็บระยะห่างของวัตถุที่ 60 องศา ***
    float d_90 = 0; // ตัวแปรที่ใช้เก็บระยะห่างของวัตถุที่ 90 องศา ***
    float d_120 = 0; // ตัวแปรที่ใช้เก็บระยะห่างของวัตถุที่ 120 องศา ***
    float d_150 = 0; // ตัวแปรที่ใช้เก็บระยะห่างของวัตถุที่ 150 องศา ***
    float d_180 = 0; // ตัวแปรที่ใช้เก็บระยะห่างของวัตถุที่ 180 องศา ***
    stop(); // สั่งให้หุ่นยนต์หยุด ***
    delay(500); // ดีเลย์ไปครึ่งวินาที ***
    backward(40, 10); //ถอยหลังมา 10 ซม. ด้วยความเร็ว 40 ซม ต่อ วินาที ***
    
    Myservo.write(10); //ขยับเซอร์โวไปด้านขวา (0 องศา) ***
    delay(500); // ดีเลย์ไปครึ่งวินาที *** 
    Get_Distance(); // ทำการวัดค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์จาก HC-SR04 ***
    d_0 = distance; // เอาค่าที่ได้จากการวัดระยะห่างของวัตถุที่ 0 องศาของเซ็นเซอร์จาก HC-SR04 ไปเก็บไว้ในตัวแปร d_0 ***
    Serial.print("ค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์ที่ 0 องศา: "); // แสดงค่าที่ได้ออกไปที่ Serial Monitor ***
    Serial.print(d_0); //แสดงค่า d_0 ที่ได้จากการถ่ายค่าจากตัวแปร distance ออกไปยัง Serial Monitor ***
    Serial.println(" เซ็นติเมตร"); //แสดงผล ***

    Myservo.write(30); //ขยับเซอร์โวไป 30 องศา ***
    delay(500); // ดีเลย์ไปครึ่งวินาที ***
    Get_Distance(); // ทำการวัดค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์จาก HC-SR04 ***
    d_30 = distance; // เอาค่าที่ได้จากการวัดระยะห่างของวัตถุที่ 30 องศาของเซ็นเซอร์จาก HC-SR04 ไปเก็บไว้ในตัวแปร d_30 ***
    Serial.print("ค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์ที่ 30 องศา: ");  // แสดงค่าที่ได้ออกไปที่ Serial Monitor ***
    Serial.print(d_30); //แสดงค่า d_30 ที่ได้จากการถ่ายค่าจากตัวแปร distance ออกไปยัง Serial Monitor ***
    Serial.println(" เซ็นติเมตร"); //แสดงผล ***

    Myservo.write(60); //ขยับเซอร์โวไป 60 องศา ***
    delay(500); // ดีเลย์ไปครึ่งวินาที ***
    Get_Distance(); // ทำการวัดค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์จาก HC-SR04 ***
    d_60 = distance; // เอาค่าที่ได้จากการวัดระยะห่างของวัตถุที่ 60 องศาของเซ็นเซอร์จาก HC-SR04 ไปเก็บไว้ในตัวแปร d_60 ***
    Serial.print("ค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์ที่ 60 องศา: ");  // แสดงค่าที่ได้ออกไปที่ Serial Monitor ***
    Serial.print(d_60); //แสดงค่า d_60 ที่ได้จากการถ่ายค่าจากตัวแปร distance ออกไปยัง Serial Monitor ***
    Serial.println(" เซ็นติเมตร"); //แสดงผล ***

    Myservo.write(90); //ขยับเซอร์โวไป 90 องศา ***
    delay(500); // ดีเลย์ไปครึ่งวินาที ***
    Get_Distance(); // ทำการวัดค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์จาก HC-SR04 ***
    d_90 = distance; // เอาค่าที่ได้จากการวัดระยะห่างของวัตถุที่ 90 องศาของเซ็นเซอร์จาก HC-SR04 ไปเก็บไว้ในตัวแปร d_90 ***
    Serial.print("ค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์ที่ 90 องศา: "); // แสดงค่าที่ได้ออกไปที่ Serial Monitor ***
    Serial.print(d_90); //แสดงค่า d_90 ที่ได้จากการถ่ายค่าจากตัวแปร distance ออกไปยัง Serial Monitor ***
    Serial.println(" เซ็นติเมตร"); //แสดงผล ***

    Myservo.write(120); //ขยับเซอร์โวไป 120 องศา ***
    delay(500); // ดีเลย์ไปครึ่งวินาที ***
    Get_Distance(); // ทำการวัดค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์จาก HC-SR04 ***
    d_120 = distance; // เอาค่าที่ได้จากการวัดระยะห่างของวัตถุที่ 120 องศาของเซ็นเซอร์จาก HC-SR04 ไปเก็บไว้ในตัวแปร d_120 ***
    Serial.print("ค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์ที่ 120 องศา: "); // แสดงค่าที่ได้ออกไปที่ Serial Monitor ***
    Serial.print(d_120); //แสดงค่า d_120 ที่ได้จากการถ่ายค่าจากตัวแปร distance ออกไปยัง Serial Monitor ***
    Serial.println(" เซ็นติเมตร"); //แสดงผล ***

    Myservo.write(150); //ขยับเซอร์โวไป 150 องศา ***
    delay(500); // ดีเลย์ไปครึ่งวินาที ***
    Get_Distance(); // ทำการวัดค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์จาก HC-SR04 ***
    d_150 = distance; // เอาค่าที่ได้จากการวัดระยะห่างของวัตถุที่ 150 องศาของเซ็นเซอร์จาก HC-SR04 ไปเก็บไว้ในตัวแปร d_150 ***
    Serial.print("ค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์ที่ 150 องศา: "); // แสดงค่าที่ได้ออกไปที่ Serial Monitor ***
    Serial.print(d_150); //แสดงค่า d_150 ที่ได้จากการถ่ายค่าจากตัวแปร distance ออกไปยัง Serial Monitor ***
    Serial.println(" เซ็นติเมตร"); //แสดงผล ***

    Myservo.write(180); //ขยับเซอร์โวไป 180 องศา ***
    delay(500); // ดีเลย์ไปครึ่งวินาที ***
    Get_Distance(); // ทำการวัดค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์จาก HC-SR04 ***
    d_180 = distance; // เอาค่าที่ได้จากการวัดระยะห่างของวัตถุที่ 180 องศาของเซ็นเซอร์จาก HC-SR04 ไปเก็บไว้ในตัวแปร d_180 ***
    Serial.print("ค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์ที่ 180 องศา: "); // แสดงค่าที่ได้ออกไปที่ Serial Monitor ***
    Serial.print(d_180); //แสดงค่า d_180 ที่ได้จากการถ่ายค่าจากตัวแปร distance ออกไปยัง Serial Monitor ***
    Serial.println(" เซ็นติเมตร"); //แสดงผล ***

    if ((d_0 > d_30)&&(d_0 > d_60)&&(d_0 > d_90)&&(d_0 > d_120)&&(d_0 > d_150)&&(d_0 > d_180)){ //กรณี 0 องศามากที่สุด ***
      Myservo.write(100); //ขยับเซอร์โวไปตรงกลาง (90 องศา) ***
      delay(500); // ดีเลย์ไปครึ่งวินาที ***
      spin_right(50, 90); // หมุนหุ่นยนต์ไปด้านขวา 90 องศาด้วยความเร็ว 50 เซ็นติเมตรต่อวินาที ***
      Get_Distance(); // ทำการวัดค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์จาก HC-SR04 ***
    }
    else if ((d_30 > d_0)&&(d_30 > d_60)&&(d_30 > d_90)&&(d_30 > d_120)&&(d_30 > d_150)&&(d_30 > d_180)){ //กรณี 30 องศามากที่สุด ***
      Myservo.write(100); //ขยับเซอร์โวไปตรงกลาง (90 องศา) ***
      delay(500); // ดีเลย์ไปครึ่งวินาที ***
      spin_right(50, 60); // หมุนหุ่นยนต์ไปด้านขวา 60 องศาด้วยความเร็ว 50 เซ็นติเมตรต่อวินาที ***
      Get_Distance(); // ทำการวัดค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์จาก HC-SR04 ***
    }
    else if ((d_60 > d_0)&&(d_60 > d_30)&&(d_60 > d_90)&&(d_60 > d_120)&&(d_60 > d_150)&&(d_60 > d_180)){ //กรณี 60 องศามากที่สุด ***
      Myservo.write(100); //ขยับเซอร์โวไปตรงกลาง (90 องศา) ***
      delay(500); // ดีเลย์ไปครึ่งวินาที ***
      spin_right(50, 30); // หมุนหุ่นยนต์ไปด้านขวา 30 องศาด้วยความเร็ว 50 เซ็นติเมตรต่อวินาที ***
      Get_Distance(); // ทำการวัดค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์จาก HC-SR04 ***
    }
    else if ((d_90 > d_0)&&(d_90 > d_30)&&(d_90 > d_60)&&(d_90 > d_120)&&(d_90 > d_150)&&(d_90 > d_180)){ //กรณี 90 องศามากที่สุด ***
      Myservo.write(100); //ขยับเซอร์โวไปตรงกลาง (90 องศา) ***
      delay(500); // ดีเลย์ไปครึ่งวินาที ***
      spin_right(50, 0); // หมุนหุ่นยนต์ไปด้านขวา 0 องศา (ไม่ต้องหมุนเลย) ด้วยความเร็ว 50 เซ็นติเมตรต่อวินาที ***
      Get_Distance(); // ทำการวัดค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์จาก HC-SR04 ***
    }
    else if ((d_120 > d_0)&&(d_120 > d_30)&&(d_120 > d_60)&&(d_120 > d_90)&&(d_120 > d_150)&&(d_120 > d_180)){ //กรณี 120 องศามากที่สุด ***
      Myservo.write(100); //ขยับเซอร์โวไปตรงกลาง (90 องศา) ***
      delay(500); // ดีเลย์ไปครึ่งวินาที ***
      spin_left(50, 30); // หมุนหุ่นยนต์ไปด้านซ้าย 30 องศา ด้วยความเร็ว 50 เซ็นติเมตรต่อวินาที ***
      Get_Distance(); // ทำการวัดค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์จาก HC-SR04 ***
    }
    else if ((d_150 > d_0)&&(d_150 > d_30)&&(d_150 > d_60)&&(d_150 > d_90)&&(d_150 > d_120)&&(d_150 > d_180)){ //กรณี 150 องศามากที่สุด ***
      Myservo.write(100); //ขยับเซอร์โวไปตรงกลาง (90 องศา) ***
      delay(500); // ดีเลย์ไปครึ่งวินาที ***
      spin_left(50, 60); // หมุนหุ่นยนต์ไปด้านซ้าย 60 องศา ด้วยความเร็ว 50 เซ็นติเมตรต่อวินาที ***
      Get_Distance(); // ทำการวัดค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์จาก HC-SR04 ***
    }
    else if ((d_180 > d_0)&&(d_180 > d_30)&&(d_180 > d_60)&&(d_180 > d_90)&&(d_180 > d_120)&&(d_180 > d_150)){ //กรณี 180 องศามากที่สุด ***
      Myservo.write(100); //ขยับเซอร์โวไปตรงกลาง (90 องศา) ***
      delay(500); // ดีเลย์ไปครึ่งวินาที ***
      spin_left(50, 90); // หมุนหุ่นยนต์ไปด้านซ้าย 90 องศา ด้วยความเร็ว 50 เซ็นติเมตรต่อวินาที ***
      Get_Distance(); // ทำการวัดค่าระยะห่างของวัตถุที่อยู่ด้านหน้าของเซ็นเซอร์จาก HC-SR04 ***
    }
  else if ((distance < 5)&&(distance > 0)) { // ระยะอยู่ต่ำกว่า 5 ซม ให้หยุด ***
    stop(); // ระยะอยู่ต่ำกว่า 5 ซม ให้หยุด ***
  } 
  }
}

